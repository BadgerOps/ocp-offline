{{define "content"}}
<style>
	.provider-actions {
		display: flex;
		gap: 8px;
		align-items: center;
	}
	.toggle-switch {
		position: relative;
		width: 44px;
		height: 24px;
		cursor: pointer;
	}
	.toggle-switch input {
		opacity: 0;
		width: 0;
		height: 0;
	}
	.toggle-slider {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background-color: #ccc;
		border-radius: 24px;
		transition: 0.3s;
	}
	.toggle-slider::before {
		content: "";
		position: absolute;
		height: 18px;
		width: 18px;
		left: 3px;
		bottom: 3px;
		background-color: white;
		border-radius: 50%;
		transition: 0.3s;
	}
	.toggle-switch input:checked + .toggle-slider {
		background-color: #27ae60;
	}
	.toggle-switch input:checked + .toggle-slider::before {
		transform: translateX(20px);
	}
	.button.small {
		padding: 6px 12px;
		font-size: 13px;
	}
	.button.secondary {
		background-color: #95a5a6;
	}
	.button.secondary:hover {
		background-color: #7f8c8d;
	}
	.form-group {
		margin-bottom: 16px;
	}
	.form-group label {
		display: block;
		margin-bottom: 6px;
		font-weight: 500;
		color: #2c3e50;
	}
	.form-group input[type="text"],
	.form-group select,
	.form-group textarea {
		width: 100%;
		padding: 10px 12px;
		border: 1px solid #ddd;
		border-radius: 4px;
		font-size: 14px;
	}
	.form-group input:focus,
	.form-group select:focus,
	.form-group textarea:focus {
		outline: none;
		border-color: #3498db;
		box-shadow: 0 0 0 2px rgba(52,152,219,0.2);
	}
	.form-row {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 16px;
	}
	.alert {
		padding: 12px 16px;
		border-radius: 4px;
		margin-top: 12px;
		font-size: 14px;
	}
	.alert-success {
		background-color: #d4edda;
		color: #155724;
		border: 1px solid #c3e6cb;
	}
	.alert-error {
		background-color: #f8d7da;
		color: #721c24;
		border: 1px solid #f5c6cb;
	}
	.coming-soon {
		display: inline-block;
		padding: 2px 8px;
		background-color: #f39c12;
		color: white;
		border-radius: 3px;
		font-size: 11px;
		margin-left: 6px;
	}
	.type-badge {
		display: inline-block;
		padding: 2px 8px;
		background-color: #ecf0f1;
		border-radius: 3px;
		font-size: 12px;
		color: #2c3e50;
	}
	.add-form-card {
		border: 2px dashed #3498db;
		background: #f8fbff;
	}
	.list-items {
		display: flex;
		flex-direction: column;
		gap: 8px;
	}
	.list-item {
		display: flex;
		gap: 8px;
		align-items: center;
	}
	.list-item input {
		flex: 1;
	}
	.list-item button {
		flex-shrink: 0;
	}
</style>

<div x-data="providerManager()" x-init="init()">
	<!-- Header with Add button -->
	<div class="card" style="display: flex; justify-content: space-between; align-items: center;">
		<div>
			<h2>Provider Management</h2>
			<p style="color: #666; margin-top: 4px;">Configure and manage content providers.</p>
		</div>
		<button class="button primary" @click="showAddForm = !showAddForm">
			<span x-show="!showAddForm">+ Add Provider</span>
			<span x-show="showAddForm">Cancel</span>
		</button>
	</div>

	<!-- Add Provider Form -->
	<div class="card add-form-card" x-show="showAddForm" x-transition>
		<h2>Add New Provider</h2>
		<form @submit.prevent="createProvider()">
			<div class="form-row">
				<div class="form-group">
					<label for="new-name">Name</label>
					<input type="text" id="new-name" x-model="newProvider.name" placeholder="e.g., epel" required>
				</div>
				<div class="form-group">
					<label for="new-type">Type</label>
					<select id="new-type" x-model="newProvider.type" required>
						<option value="">Select a type...</option>
						<option value="epel">EPEL Repository</option>
						<option value="ocp_binaries">OCP Binaries</option>
						<option value="rhcos">RHCOS Images</option>
						<option value="container_images">Container Images</option>
						<option value="registry">Mirror Registry</option>
						<option value="custom_files">Custom Files</option>
					</select>
				</div>
			</div>

			<div class="form-group">
				<label>
					<input type="checkbox" x-model="newProvider.enabled"> Enabled
				</label>
			</div>

			<!-- Type-specific fields -->
			<template x-if="newProvider.type === 'epel'">
				<div>
					<h3 style="margin-bottom: 12px;">EPEL Configuration</h3>

					<!-- Version and Architecture Selection -->
					<div class="form-row">
						<div class="form-group">
							<label>EPEL Version</label>
							<select x-model="epelVersion" @change="epelMirrors = []; selectedMirror = null">
								<option value="">Select version...</option>
								<template x-for="v in epelVersions" :key="v.version">
									<option :value="v.version" x-text="'EPEL ' + v.version"></option>
								</template>
							</select>
						</div>
						<div class="form-group">
							<label>Architecture</label>
							<select x-model="epelArch" @change="epelMirrors = []; selectedMirror = null">
								<option value="x86_64">x86_64</option>
								<option value="aarch64">aarch64</option>
								<option value="ppc64le">ppc64le</option>
								<option value="s390x">s390x</option>
							</select>
						</div>
					</div>

					<div style="margin-bottom: 16px;">
						<button type="button" class="button" @click="discoverEPELMirrors()" :disabled="!epelVersion || discoveringMirrors">
							<span x-show="!discoveringMirrors">Discover Mirrors</span>
							<span x-show="discoveringMirrors">Discovering...</span>
						</button>
						<button type="button" class="button secondary" x-show="epelMirrors.length > 0" @click="testMirrorSpeed()" :disabled="testingSpeed" style="margin-left: 8px;">
							<span x-show="!testingSpeed">Test Speed</span>
							<span x-show="testingSpeed">Testing...</span>
						</button>
					</div>

					<!-- Mirror List -->
					<div x-show="epelMirrors.length > 0" style="margin-bottom: 16px;">
						<label>Select a Mirror</label>
						<div style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;">
							<table style="margin-bottom: 0; box-shadow: none;">
								<thead>
									<tr>
										<th style="width: 30px;"></th>
										<th>URL</th>
										<th style="width: 60px;">Country</th>
										<th style="width: 50px;">Pref</th>
										<th x-show="speedResults.length > 0" style="width: 80px;">Latency</th>
										<th x-show="speedResults.length > 0" style="width: 100px;">Speed</th>
									</tr>
								</thead>
								<tbody>
									<template x-for="(m, idx) in epelMirrors" :key="m.url">
										<tr @click="selectMirror(m)" style="cursor: pointer;" :style="selectedMirror === m.url ? 'background-color: #ebf5fb' : ''">
											<td><input type="radio" :checked="selectedMirror === m.url" name="mirror_select"></td>
											<td style="font-size: 12px; word-break: break-all;" x-text="m.url"></td>
											<td x-text="m.country"></td>
											<td x-text="m.preference"></td>
											<td x-show="speedResults.length > 0" x-text="getSpeedResult(m.url, 'latency')"></td>
											<td x-show="speedResults.length > 0" x-text="getSpeedResult(m.url, 'throughput')"></td>
										</tr>
									</template>
								</tbody>
							</table>
						</div>
					</div>

					<!-- Repositories (auto-filled from selection or manual) -->
					<div class="form-group">
						<label>Repositories</label>
						<div class="list-items">
							<template x-for="(repo, idx) in newProvider.config.repos" :key="idx">
								<div class="list-item">
									<input type="text" x-model="repo.name" placeholder="Repo name (e.g., epel-9)">
									<input type="text" x-model="repo.base_url" placeholder="Base URL">
									<input type="text" x-model="repo.output_dir" placeholder="Output dir">
									<button type="button" class="button danger small" @click="newProvider.config.repos.splice(idx, 1)">X</button>
								</div>
							</template>
							<button type="button" class="button small secondary" @click="newProvider.config.repos.push({name:'',base_url:'',output_dir:''})">+ Add Repo</button>
						</div>
					</div>
				</div>
			</template>

			<template x-if="newProvider.type === 'ocp_binaries' || newProvider.type === 'rhcos'">
				<div>
					<h3 style="margin-bottom: 12px;" x-text="newProvider.type === 'ocp_binaries' ? 'OCP Binaries Configuration' : 'RHCOS Configuration'"></h3>
					<div class="form-group">
						<label>Base URL</label>
						<input type="text" x-model="newProvider.config.base_url" :placeholder="newProvider.type === 'ocp_binaries' ? 'https://mirror.openshift.com/pub/openshift-v4/clients/ocp' : 'https://mirror.openshift.com/pub/openshift-v4/dependencies/rhcos'">
					</div>
					<div class="form-group">
						<label>Output Directory</label>
						<input type="text" x-model="newProvider.config.output_dir" :placeholder="newProvider.type === 'ocp_binaries' ? 'ocp-binaries' : 'rhcos-images'">
					</div>

					<div style="margin-bottom: 16px;">
						<button type="button" class="button" @click="loadOCPVersions()" :disabled="loadingVersions">
							<span x-show="!loadingVersions">Load Available Versions</span>
							<span x-show="loadingVersions">Loading...</span>
						</button>
					</div>

					<!-- Version Selection -->
					<div x-show="ocpVersionsLoaded">
						<template x-if="newProvider.type === 'ocp_binaries'">
							<div>
								<div class="form-group" x-show="ocpChannels.length > 0">
									<label>Channels (recommended)</label>
									<div class="checkbox-group" style="display: flex; flex-wrap: wrap; gap: 12px;">
										<template x-for="ch in ocpChannels" :key="ch.version">
											<label style="min-width: 180px; font-weight: normal; cursor: pointer; display: flex; align-items: center; gap: 6px;">
												<input type="checkbox" :value="ch.version" x-model="selectedVersions"> <span x-text="ch.version"></span>
											</label>
										</template>
									</div>
								</div>
								<div class="form-group" x-show="ocpReleases.length > 0">
									<label>Specific Releases <small style="color: #999;">(showing latest 20)</small></label>
									<div class="checkbox-group" style="display: flex; flex-wrap: wrap; gap: 12px;">
										<template x-for="rel in ocpReleases.slice(0, 20)" :key="rel.version">
											<label style="min-width: 120px; font-weight: normal; cursor: pointer; display: flex; align-items: center; gap: 6px;">
												<input type="checkbox" :value="rel.version" x-model="selectedVersions"> <span x-text="rel.version"></span>
											</label>
										</template>
									</div>
								</div>
							</div>
						</template>

						<template x-if="newProvider.type === 'rhcos'">
							<div class="form-group" x-show="rhcosVersions.length > 0">
								<label>RHCOS Versions</label>
								<div class="checkbox-group" style="display: flex; flex-wrap: wrap; gap: 12px;">
									<template x-for="rv in rhcosVersions" :key="rv.minor">
										<label style="min-width: 120px; font-weight: normal; cursor: pointer; display: flex; align-items: center; gap: 6px;">
											<input type="checkbox" :value="rv.minor" x-model="selectedVersions"> <span x-text="'RHCOS ' + rv.minor"></span>
											<small x-show="rv.builds && rv.builds.length > 0" style="color: #999;" x-text="'(' + rv.builds.length + ' builds)'"></small>
										</label>
									</template>
								</div>
							</div>
						</template>
					</div>

					<!-- Fallback: manual versions input -->
					<div class="form-group" x-show="!ocpVersionsLoaded">
						<label>Versions (comma-separated)</label>
						<input type="text" x-model="newProvider.config.versions_str" placeholder="4.14.10, 4.15.2, stable-4.15">
					</div>
				</div>
			</template>

			<template x-if="newProvider.type === 'container_images'">
				<div>
					<h3 style="margin-bottom: 12px;">Container Images Configuration</h3>
					<span class="coming-soon">Coming Soon</span>
					<p style="color: #666; margin-top: 8px;">This provider type is not yet implemented. You can save the config for later.</p>
				</div>
			</template>

			<template x-if="newProvider.type === 'registry'">
				<div>
					<h3 style="margin-bottom: 12px;">Mirror Registry Configuration</h3>
					<span class="coming-soon">Coming Soon</span>
					<p style="color: #666; margin-top: 8px;">This provider type is not yet implemented. You can save the config for later.</p>
				</div>
			</template>

			<template x-if="newProvider.type === 'custom_files'">
				<div>
					<h3 style="margin-bottom: 12px;">Custom Files Configuration</h3>
					<span class="coming-soon">Coming Soon</span>
					<p style="color: #666; margin-top: 8px;">This provider type is not yet implemented. You can save the config for later.</p>
				</div>
			</template>

			<div style="margin-top: 16px;">
				<button type="submit" class="button primary">Create Provider</button>
			</div>
		</form>
		<div x-show="message" :class="'alert alert-' + messageType" x-text="message" x-transition></div>
	</div>

	<!-- Provider List -->
	<div class="card">
		<table x-show="configs.length > 0">
			<thead>
				<tr>
					<th>Name</th>
					<th>Type</th>
					<th>Enabled</th>
					<th>Files</th>
					<th>Size</th>
					<th>Actions</th>
				</tr>
			</thead>
			<tbody>
				<template x-for="pc in configs" :key="pc.name">
					<tr>
						<td><strong x-text="pc.name"></strong></td>
						<td><span class="type-badge" x-text="pc.type"></span></td>
						<td>
							<label class="toggle-switch" @click.prevent="toggleProvider(pc.name)">
								<input type="checkbox" :checked="pc.enabled">
								<span class="toggle-slider"></span>
							</label>
						</td>
						<td x-text="getFileCount(pc.name)"></td>
						<td x-text="getFileSize(pc.name)"></td>
						<td>
							<div class="provider-actions">
								<a :href="'/providers/' + pc.name" class="button small">Details</a>
								<button class="button small danger" @click="deleteProvider(pc.name)">Delete</button>
							</div>
						</td>
					</tr>
				</template>
			</tbody>
		</table>
		<p x-show="configs.length === 0" style="color: #666;">No providers configured. Click "Add Provider" to get started.</p>
	</div>
</div>

<script>
function providerManager() {
	const statuses = {};
	{{range $name, $status := .Statuses}}
	statuses["{{$name}}"] = {
		fileCount: {{$status.FileCount}},
		totalSize: {{$status.TotalSize}}
	};
	{{end}}

	return {
		configs: [],
		statuses: statuses,
		showAddForm: false,
		message: '',
		messageType: 'success',
		newProvider: {
			name: '',
			type: '',
			enabled: true,
			config: {
				repos: [{name: '', base_url: '', output_dir: ''}],
				base_url: '',
				output_dir: '',
				versions_str: ''
			}
		},

		// EPEL mirror discovery state
		epelVersions: [],
		epelVersion: '',
		epelArch: 'x86_64',
		epelMirrors: [],
		selectedMirror: null,
		discoveringMirrors: false,
		testingSpeed: false,
		speedResults: [],

		// OCP/RHCOS version discovery state
		ocpChannels: [],
		ocpReleases: [],
		rhcosVersions: [],
		ocpVersionsLoaded: false,
		loadingVersions: false,
		selectedVersions: [],

		async init() {
			await this.loadConfigs();
			try {
				const resp = await fetch('/api/mirrors/epel/versions');
				if (resp.ok) this.epelVersions = await resp.json();
			} catch (e) {
				console.error('Failed to load EPEL versions:', e);
			}
		},

		async loadConfigs() {
			try {
				const resp = await fetch('/api/providers/config');
				this.configs = await resp.json();
			} catch (e) {
				console.error('Failed to load configs:', e);
			}
		},

		getFileCount(name) {
			return this.statuses[name] ? this.statuses[name].fileCount : 0;
		},

		getFileSize(name) {
			const size = this.statuses[name] ? this.statuses[name].totalSize : 0;
			return formatBytes(size);
		},

		async discoverEPELMirrors() {
			this.discoveringMirrors = true;
			this.epelMirrors = [];
			this.speedResults = [];
			this.selectedMirror = null;
			try {
				const resp = await fetch('/api/mirrors/epel?version=' + this.epelVersion + '&arch=' + this.epelArch);
				if (resp.ok) {
					this.epelMirrors = await resp.json();
				} else {
					const err = await resp.json();
					this.message = err.error || 'Failed to discover mirrors';
					this.messageType = 'error';
				}
			} catch (e) {
				this.message = 'Network error: ' + e.message;
				this.messageType = 'error';
			}
			this.discoveringMirrors = false;
		},

		async testMirrorSpeed() {
			this.testingSpeed = true;
			this.speedResults = [];
			const urls = this.epelMirrors.map(m => m.url);
			try {
				const resp = await fetch('/api/mirrors/speedtest', {
					method: 'POST',
					headers: {'Content-Type': 'application/json'},
					body: JSON.stringify({urls: urls, top_n: 10})
				});
				if (resp.ok) {
					this.speedResults = await resp.json();
					const speedMap = {};
					this.speedResults.forEach(r => { speedMap[r.url] = r; });
					this.epelMirrors.sort((a, b) => {
						const sa = speedMap[a.url], sb = speedMap[b.url];
						if (!sa || sa.error) return 1;
						if (!sb || sb.error) return -1;
						return sb.throughput_kbps - sa.throughput_kbps;
					});
				}
			} catch (e) {
				console.error('Speed test failed:', e);
			}
			this.testingSpeed = false;
		},

		getSpeedResult(url, field) {
			const r = this.speedResults.find(s => s.url === url);
			if (!r) return '-';
			if (r.error) return 'err';
			if (field === 'latency') return r.latency_ms + 'ms';
			if (field === 'throughput') return r.throughput_kbps > 0 ? r.throughput_kbps.toFixed(1) + ' KB/s' : '-';
			return '-';
		},

		selectMirror(m) {
			this.selectedMirror = m.url;
			const repoName = 'epel-' + this.epelVersion;
			if (this.newProvider.config.repos.length === 0) {
				this.newProvider.config.repos.push({name: '', base_url: '', output_dir: ''});
			}
			this.newProvider.config.repos[0].name = repoName;
			this.newProvider.config.repos[0].base_url = m.url;
			this.newProvider.config.repos[0].output_dir = repoName;
			if (!this.newProvider.name) {
				this.newProvider.name = repoName;
			}
		},

		async loadOCPVersions() {
			this.loadingVersions = true;
			this.ocpChannels = [];
			this.ocpReleases = [];
			this.rhcosVersions = [];
			this.selectedVersions = [];
			try {
				const resp = await fetch('/api/mirrors/ocp/versions');
				if (resp.ok) {
					const data = await resp.json();
					if (data.ocp) {
						this.ocpChannels = data.ocp.filter(v => v.channel !== 'release');
						this.ocpReleases = data.ocp.filter(v => v.channel === 'release');
					}
					if (data.rhcos) {
						this.rhcosVersions = data.rhcos;
					}
					this.ocpVersionsLoaded = true;
					if (!this.newProvider.config.base_url) {
						if (this.newProvider.type === 'ocp_binaries') {
							this.newProvider.config.base_url = 'https://mirror.openshift.com/pub/openshift-v4/clients/ocp';
						} else if (this.newProvider.type === 'rhcos') {
							this.newProvider.config.base_url = 'https://mirror.openshift.com/pub/openshift-v4/dependencies/rhcos';
						}
					}
				} else {
					const err = await resp.json();
					this.message = err.error || 'Failed to load versions';
					this.messageType = 'error';
				}
			} catch (e) {
				this.message = 'Network error: ' + e.message;
				this.messageType = 'error';
			}
			this.loadingVersions = false;
		},

		async createProvider() {
			this.message = '';
			const cfg = Object.assign({}, this.newProvider.config);

			if (this.selectedVersions.length > 0) {
				cfg.versions = this.selectedVersions;
			} else if (cfg.versions_str) {
				cfg.versions = cfg.versions_str.split(',').map(v => v.trim()).filter(v => v);
			}
			delete cfg.versions_str;

			if (cfg.repos) {
				cfg.repos = cfg.repos.filter(r => r.name || r.base_url);
			}

			const body = {
				name: this.newProvider.name,
				type: this.newProvider.type,
				enabled: this.newProvider.enabled,
				config: cfg
			};

			try {
				const resp = await fetch('/api/providers/config', {
					method: 'POST',
					headers: {'Content-Type': 'application/json'},
					body: JSON.stringify(body)
				});

				if (resp.ok) {
					this.message = 'Provider created successfully';
					this.messageType = 'success';
					this.showAddForm = false;
					this.resetForm();
					await this.loadConfigs();
				} else {
					const err = await resp.json();
					this.message = err.error || 'Failed to create provider';
					this.messageType = 'error';
				}
			} catch (e) {
				this.message = 'Network error: ' + e.message;
				this.messageType = 'error';
			}
		},

		async toggleProvider(name) {
			try {
				const resp = await fetch('/api/providers/config/' + name + '/toggle', {method: 'POST'});
				if (resp.ok) {
					await this.loadConfigs();
				}
			} catch (e) {
				console.error('Toggle failed:', e);
			}
		},

		async deleteProvider(name) {
			if (!confirm('Delete provider "' + name + '"? This cannot be undone.')) return;
			try {
				const resp = await fetch('/api/providers/config/' + name, {method: 'DELETE'});
				if (resp.ok) {
					await this.loadConfigs();
				}
			} catch (e) {
				console.error('Delete failed:', e);
			}
		},

		resetForm() {
			this.newProvider = {
				name: '',
				type: '',
				enabled: true,
				config: {
					repos: [{name: '', base_url: '', output_dir: ''}],
					base_url: '',
					output_dir: '',
					versions_str: ''
				}
			};
			this.epelMirrors = [];
			this.selectedMirror = null;
			this.speedResults = [];
			this.ocpVersionsLoaded = false;
			this.selectedVersions = [];
		}
	};
}

function formatBytes(bytes) {
	if (bytes === 0) return '0 B';
	const k = 1024;
	const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
	const i = Math.floor(Math.log(bytes) / Math.log(k));
	return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}
</script>
{{end}}
