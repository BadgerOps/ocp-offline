{{define "content"}}
<div x-data="providerManager()" x-init="init()">
	<!-- Header with Add button -->
		<div class="card" style="display: flex; justify-content: space-between; align-items: center;">
			<div>
				<h2>Provider Management</h2>
				<p class="card-desc">Configure and manage content providers.</p>
			</div>
			<button class="btn btn-primary" @click="showAddForm ? cancelForm() : startCreateMode()">
				<span x-show="!showAddForm">+ Add Provider</span>
				<span x-show="showAddForm && !isEditing">Cancel</span>
				<span x-show="showAddForm && isEditing">Cancel Edit</span>
			</button>
		</div>

	<!-- Status Messages -->
	<div x-show="message" x-transition :class="'alert alert-' + messageType" x-text="message" style="margin-bottom: 20px;"></div>

		<!-- Create/Edit Provider Form -->
		<div class="card add-form-card" x-show="showAddForm" x-transition>
			<h2 x-text="isEditing ? ('Edit Provider: ' + editingProviderName) : 'New Provider'"></h2>
			<p class="card-desc" x-text="isEditing ? 'Update provider configuration.' : 'Select a provider type and configure it.'"></p>
			<form @submit.prevent="saveProvider()">
				<div class="form-row">
					<div class="form-group">
						<label for="new-name">Name</label>
						<input type="text" id="new-name" x-model="newProvider.name" placeholder="e.g., epel-9" required :readonly="isEditing" :disabled="isEditing">
					</div>
					<div class="form-group">
						<label for="new-type">Type</label>
						<select id="new-type" x-model="newProvider.type" required :disabled="isEditing">
							<option value="">Select a type&hellip;</option>
							<option value="epel">EPEL Repository</option>
							<option value="ocp_binaries">OCP Binaries</option>
						<option value="ocp_clients">OCP Clients (oc + installer)</option>
						<option value="rhcos">RHCOS Images</option>
						<option value="container_images">Container Images</option>
						<option value="registry">Mirror Registry</option>
						<option value="custom_files">Custom Files</option>
					</select>
				</div>
			</div>

				<div class="form-group" style="margin-bottom: 20px;">
					<label style="display: inline-flex; align-items: center; gap: 8px; text-transform: none; letter-spacing: normal; font-size: 13px; cursor: pointer;">
						<input type="checkbox" x-model="newProvider.enabled">
						<span x-text="isEditing ? 'Enabled' : 'Enabled on creation'"></span>
					</label>
				</div>

			<!-- EPEL Configuration -->
			<template x-if="newProvider.type === 'epel'">
				<div>
					<hr class="section-divider">
					<h2>EPEL Configuration</h2>
					<p class="card-desc">Discover mirrors automatically or configure repositories manually.</p>

					<div class="form-row">
						<div class="form-group">
							<label>EPEL Version</label>
							<select x-model="epelVersion" @change="epelMirrors = []; selectedMirror = null">
								<option value="">Select version&hellip;</option>
								<template x-for="v in epelVersions" :key="v.version">
									<option :value="v.version" x-text="'EPEL ' + v.version"></option>
								</template>
							</select>
						</div>
						<div class="form-group">
							<label>Architecture</label>
							<select x-model="epelArch" @change="epelMirrors = []; selectedMirror = null">
								<option value="x86_64">x86_64</option>
								<option value="aarch64">aarch64</option>
								<option value="ppc64le">ppc64le</option>
								<option value="s390x">s390x</option>
							</select>
						</div>
					</div>

					<div class="btn-group" style="margin-bottom: 20px;">
						<button type="button" class="btn" @click="discoverEPELMirrors()" :disabled="!epelVersion || discoveringMirrors">
							<span x-show="!discoveringMirrors">Discover Mirrors</span>
							<span x-show="discoveringMirrors"><span class="spinner"></span> Discovering&hellip;</span>
						</button>
						<button type="button" class="btn" x-show="epelMirrors.length > 0" @click="testMirrorSpeed()" :disabled="testingSpeed">
							<span x-show="!testingSpeed">Test Speed</span>
							<span x-show="testingSpeed"><span class="spinner"></span> Testing&hellip;</span>
						</button>
					</div>

					<!-- Mirror List -->
					<div x-show="epelMirrors.length > 0" style="margin-bottom: 20px;">
						<div class="form-group">
							<label>Select a Mirror</label>
						</div>
						<div style="max-height: 280px; overflow-y: auto; border: 1px solid var(--border-subtle); border-radius: var(--radius);">
							<table style="margin-bottom: 0;">
								<thead>
									<tr>
										<th style="width: 30px;"></th>
										<th>URL</th>
										<th style="width: 60px;">Country</th>
										<th style="width: 50px;">Pref</th>
										<th x-show="speedResults.length > 0" style="width: 80px;">Latency</th>
										<th x-show="speedResults.length > 0" style="width: 100px;">Speed</th>
									</tr>
								</thead>
								<tbody>
									<template x-for="(m, idx) in epelMirrors" :key="m.url">
										<tr @click="selectMirror(m)" style="cursor: pointer;" :style="selectedMirror === m.url ? 'background: var(--accent-dim)' : ''">
											<td><input type="radio" :checked="selectedMirror === m.url" name="mirror_select"></td>
											<td style="font-family: var(--font-mono); font-size: 11px; word-break: break-all;" x-text="m.url"></td>
											<td x-text="m.country"></td>
											<td x-text="m.preference"></td>
											<td x-show="speedResults.length > 0" style="font-family: var(--font-mono); font-size: 12px;" x-text="getSpeedResult(m.url, 'latency')"></td>
											<td x-show="speedResults.length > 0" style="font-family: var(--font-mono); font-size: 12px;" x-text="getSpeedResult(m.url, 'throughput')"></td>
										</tr>
									</template>
								</tbody>
							</table>
						</div>
					</div>

					<!-- Repositories -->
					<div class="form-group">
						<label>Repositories</label>
						<div class="list-items">
							<template x-for="(repo, idx) in newProvider.config.repos" :key="idx">
								<div class="list-item">
									<input type="text" x-model="repo.name" placeholder="Name (e.g., epel-9)" style="margin-bottom: 0;">
									<input type="text" x-model="repo.base_url" placeholder="Base URL" style="margin-bottom: 0;">
									<input type="text" x-model="repo.output_dir" placeholder="Output dir" style="margin-bottom: 0;">
									<button type="button" class="btn btn-danger btn-sm" @click="newProvider.config.repos.splice(idx, 1)">X</button>
								</div>
							</template>
							<button type="button" class="btn btn-sm" @click="newProvider.config.repos.push({name:'',base_url:'',output_dir:''})">+ Add Repo</button>
						</div>
					</div>
				</div>
			</template>

			<!-- OCP / RHCOS Configuration -->
			<template x-if="newProvider.type === 'ocp_binaries' || newProvider.type === 'rhcos'">
				<div>
					<hr class="section-divider">
					<h2 x-text="newProvider.type === 'ocp_binaries' ? 'OCP Binaries Configuration' : 'RHCOS Configuration'"></h2>
					<p class="card-desc">Fetch available versions from the upstream mirror.</p>

					<div class="form-group">
						<label>Base URL</label>
						<input type="text" x-model="newProvider.config.base_url" :placeholder="newProvider.type === 'ocp_binaries' ? 'https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp' : 'https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos'">
					</div>
					<div class="form-group">
						<label>Output Directory</label>
						<input type="text" x-model="newProvider.config.output_dir" :placeholder="newProvider.type === 'ocp_binaries' ? 'ocp-binaries' : 'rhcos-images'">
					</div>

					<div style="margin-bottom: 20px;">
						<button type="button" class="btn" @click="loadOCPVersions()" :disabled="loadingVersions">
							<span x-show="!loadingVersions">Load Available Versions</span>
							<span x-show="loadingVersions"><span class="spinner"></span> Loading&hellip;</span>
						</button>
					</div>

					<!-- Version Selection -->
					<div x-show="ocpVersionsLoaded">
						<template x-if="newProvider.type === 'ocp_binaries'">
							<div>
								<div class="form-group" x-show="ocpChannels.length > 0">
									<label>Channels (recommended)</label>
									<div class="checkbox-group">
										<template x-for="ch in ocpChannels" :key="ch.version">
											<label>
												<input type="checkbox" :value="ch.version" x-model="selectedVersions"> <span x-text="ch.version"></span>
											</label>
										</template>
									</div>
								</div>
								<div class="form-group" x-show="ocpReleases.length > 0">
									<label>Specific Releases <span style="font-weight: 400; color: var(--text-muted); text-transform: none;">(latest 20)</span></label>
									<div class="checkbox-group">
										<template x-for="rel in ocpReleases.slice(0, 20)" :key="rel.version">
											<label>
												<input type="checkbox" :value="rel.version" x-model="selectedVersions"> <span x-text="rel.version"></span>
											</label>
										</template>
									</div>
								</div>
							</div>
						</template>

						<template x-if="newProvider.type === 'rhcos'">
							<div class="form-group" x-show="rhcosVersions.length > 0">
								<label>RHCOS Versions</label>
								<div class="checkbox-group">
									<template x-for="rv in rhcosVersions" :key="rv.minor">
										<label>
											<input type="checkbox" :value="rv.minor" x-model="selectedVersions">
											<span x-text="'RHCOS ' + rv.minor"></span>
											<span x-show="rv.builds && rv.builds.length > 0" style="color: var(--text-muted); font-size: 11px;" x-text="'(' + rv.builds.length + ' builds)'"></span>
										</label>
									</template>
								</div>
							</div>
						</template>
					</div>

					<!-- Fallback: manual versions input -->
					<div class="form-group" x-show="!ocpVersionsLoaded">
						<label>Versions (comma-separated)</label>
						<input type="text" x-model="newProvider.config.versions_str" placeholder="4.14.10, 4.15.2, stable-4.15">
					</div>
				</div>
			</template>

			<!-- OCP Clients Configuration -->
			<template x-if="newProvider.type === 'ocp_clients'">
				<div>
					<hr class="section-divider">
					<h2>OCP Clients Configuration</h2>
					<p class="card-desc">Auto-discover and sync <code style="font-family: var(--font-mono); background: var(--bg-hover); padding: 1px 6px; border-radius: 3px;">oc</code> and <code style="font-family: var(--font-mono); background: var(--bg-hover); padding: 1px 6px; border-radius: 3px;">openshift-install</code> binaries. Channels auto-sync new patch releases.</p>

					<div class="form-group">
						<label>Output Directory</label>
						<input type="text" x-model="newProvider.config.output_dir" placeholder="ocp-clients">
					</div>

					<!-- Fetch Channels -->
					<div style="margin-bottom: 20px;">
						<button type="button" class="btn" @click="fetchOCPClientChannels()" :disabled="ocpClientsFetching">
							<span x-show="!ocpClientsFetching">Fetch Available Channels</span>
							<span x-show="ocpClientsFetching"><span class="spinner"></span> Fetching&hellip;</span>
						</button>
					</div>

					<!-- Channel Selection -->
					<div x-show="ocpClientTracks && ocpClientTracks.groups && ocpClientTracks.groups.length > 0">
						<div class="form-group">
							<label>Channels <span style="font-weight: 400; color: var(--text-muted); text-transform: none;">(auto-discovers new patch releases on each sync)</span></label>
						</div>
						<template x-for="group in ocpClientTracks.groups" :key="group.type">
							<div style="margin-bottom: 12px;">
								<div style="text-transform: uppercase; font-size: 11px; font-weight: 600; letter-spacing: 0.05em; color: var(--text-muted); margin-bottom: 6px;" x-text="group.type"></div>
								<div class="checkbox-group">
									<template x-for="ch in group.channels" :key="ch">
										<label>
											<input type="checkbox" :value="ch" x-model="selectedOCPClientChannels"> <span x-text="ch"></span>
										</label>
									</template>
								</div>
							</div>
						</template>
					</div>

					<!-- Pinned Versions -->
					<div class="form-group" style="margin-top: 12px;">
						<label>Pinned Versions <span style="font-weight: 400; color: var(--text-muted); text-transform: none;">(optional, comma-separated)</span></label>
						<input type="text" x-model="newProvider.config.versions_str" placeholder="e.g., 4.21.1, 4.20.5">
					</div>

					<!-- Platform Selection -->
					<div class="form-group" style="margin-top: 12px;">
						<label>Platforms</label>
						<div class="checkbox-group">
							<label><input type="checkbox" value="linux" x-model="selectedOCPClientPlatforms"> Linux (x86_64)</label>
							<label><input type="checkbox" value="linux-arm64" x-model="selectedOCPClientPlatforms"> Linux (ARM64)</label>
							<label><input type="checkbox" value="mac" x-model="selectedOCPClientPlatforms"> macOS (x86_64)</label>
							<label><input type="checkbox" value="mac-arm64" x-model="selectedOCPClientPlatforms"> macOS (ARM64)</label>
							<label><input type="checkbox" value="windows" x-model="selectedOCPClientPlatforms"> Windows</label>
						</div>
					</div>
				</div>
			</template>

			<!-- Container Images Configuration -->
			<template x-if="newProvider.type === 'container_images'">
				<div>
					<hr class="section-divider">
					<h2>Container Images Configuration</h2>
					<p class="card-desc">Mirror container images from <code style="font-family: var(--font-mono); background: var(--bg-hover); padding: 1px 6px; border-radius: 3px;">docker://</code> or <code style="font-family: var(--font-mono); background: var(--bg-hover); padding: 1px 6px; border-radius: 3px;">oci://</code> references.</p>

					<div class="form-group">
						<label>Output Directory</label>
						<input type="text" x-model="newProvider.config.output_dir" placeholder="images">
					</div>

					<div class="form-group">
						<label>Image References <span style="font-weight: 400; color: var(--text-muted); text-transform: none;">(one per line)</span></label>
						<textarea x-model="containerImageInput" rows="6" placeholder="docker://quay.io/openshift-release-dev/ocp-release:4.16.35&#10;oci://registry.example.com/team/app:1.2.3"></textarea>
						<div style="display: flex; gap: 8px; align-items: center; margin-top: 8px;">
							<button type="button" class="btn btn-sm" @click="addContainerImagesFromInput()">+ Add Lines</button>
							<label class="btn btn-sm" for="container-image-import" style="margin: 0;">Import File</label>
							<input id="container-image-import" type="file" accept=".txt,text/plain" @change="importContainerImageFile($event)" style="display: none;">
						</div>
						<p class="card-desc" style="margin-top: 8px;">Import accepts a newline-separated text file. Blank lines and lines starting with <code style="font-family: var(--font-mono); background: var(--bg-hover); padding: 1px 6px; border-radius: 3px;">#</code> are ignored.</p>
					</div>

					<div class="form-group">
						<label>Selected Images</label>
						<div class="list-items">
							<template x-for="(img, idx) in containerImageRefs" :key="img + '-' + idx">
								<div class="list-item">
									<input type="text" x-model="containerImageRefs[idx]" style="margin-bottom: 0; font-family: var(--font-mono);" placeholder="docker://registry/repo:tag">
									<button type="button" class="btn btn-danger btn-sm" @click="containerImageRefs.splice(idx, 1)">X</button>
								</div>
							</template>
							<div x-show="containerImageRefs.length === 0" class="card-desc">No images added yet.</div>
						</div>
					</div>
				</div>
			</template>

			<template x-if="newProvider.type === 'registry'">
				<div>
					<hr class="section-divider">
					<h2>Mirror Registry <span class="coming-soon">Coming Soon</span></h2>
					<p class="card-desc">This provider type is not yet implemented. You can save the config for later.</p>
				</div>
			</template>

			<template x-if="newProvider.type === 'custom_files'">
				<div>
					<hr class="section-divider">
					<h2>Custom Files <span class="coming-soon">Coming Soon</span></h2>
					<p class="card-desc">This provider type is not yet implemented. You can save the config for later.</p>
				</div>
			</template>

				<div style="margin-top: 20px; display: flex; gap: 8px;">
					<button type="submit" class="btn btn-primary" x-text="isEditing ? 'Save Changes' : 'Create Provider'"></button>
					<button type="button" class="btn" @click="cancelForm()">Cancel</button>
				</div>
			</form>
		</div>

	<!-- Provider List -->
	<div class="card">
		<div x-show="configs.length > 0" style="overflow-x: auto;">
			<table>
				<thead>
					<tr>
						<th>Name</th>
						<th>Type</th>
						<th>Enabled</th>
						<th>Files</th>
						<th>Size</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody>
					<template x-for="pc in configs" :key="pc.name">
						<tr>
							<td><strong style="color: var(--text-primary);" x-text="pc.name"></strong></td>
							<td><span class="type-badge" x-text="pc.type"></span></td>
							<td>
								<label class="toggle-switch" @click.prevent="toggleProvider(pc.name)">
									<input type="checkbox" :checked="pc.enabled">
									<span class="toggle-slider"></span>
								</label>
							</td>
							<td style="font-family: var(--font-mono); font-size: 13px;" x-text="getFileCount(pc.name)"></td>
							<td style="font-family: var(--font-mono); font-size: 13px;" x-text="getFileSize(pc.name)"></td>
								<td>
									<div class="provider-actions">
										<a :href="'/providers/' + pc.name" class="btn btn-sm">Details</a>
										<button class="btn btn-sm" @click="startEditMode(pc)">Edit</button>
										<button class="btn btn-sm btn-danger" @click="deleteProvider(pc.name)">Delete</button>
									</div>
								</td>
						</tr>
					</template>
				</tbody>
			</table>
		</div>
			<div x-show="configs.length === 0" class="empty-state">
				<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"/></svg>
				<p>No providers configured yet.</p>
				<button class="btn btn-primary" @click="startCreateMode()">+ Add Your First Provider</button>
			</div>
		</div>
	</div>

<script>
function providerManager() {
	const statuses = {};
	{{range $name, $status := .Statuses}}
	statuses["{{$name}}"] = {
		fileCount: {{$status.FileCount}},
		totalSize: {{$status.TotalSize}}
	};
	{{end}}

		return {
			configs: [],
			statuses: statuses,
			showAddForm: false,
			isEditing: false,
			editingProviderName: '',
			message: '',
			messageType: 'success',
			newProvider: {
			name: '',
			type: '',
			enabled: true,
			config: {
				repos: [{name: '', base_url: '', output_dir: ''}],
				base_url: '',
				output_dir: '',
				versions_str: ''
				}
			},

			startCreateMode() {
				this.resetForm();
				this.showAddForm = true;
			},

			startEditMode(pc) {
				this.resetForm();
				this.showAddForm = true;
				this.isEditing = true;
				this.editingProviderName = pc.name;
				this.newProvider.name = pc.name;
				this.newProvider.type = pc.type;
				this.newProvider.enabled = !!pc.enabled;
				this.newProvider.config = this.deepClone(pc.config || {});

				if (pc.type === 'epel') {
					const repos = Array.isArray(this.newProvider.config.repos) ? this.newProvider.config.repos : [];
					this.newProvider.config.repos = repos.map(r => ({
						name: r && r.name ? String(r.name) : '',
						base_url: r && r.base_url ? String(r.base_url) : '',
						output_dir: r && r.output_dir ? String(r.output_dir) : ''
					}));
					if (this.newProvider.config.repos.length === 0) {
						this.newProvider.config.repos = [{name: '', base_url: '', output_dir: ''}];
					}
				}

				if (pc.type === 'ocp_binaries' || pc.type === 'rhcos') {
					const versions = Array.isArray(this.newProvider.config.versions) ? this.newProvider.config.versions : [];
					this.selectedVersions = versions.map(v => String(v));
					this.newProvider.config.versions_str = this.selectedVersions.join(', ');
				}

				if (pc.type === 'ocp_clients') {
					const channels = Array.isArray(this.newProvider.config.channels) ? this.newProvider.config.channels : [];
					const platforms = Array.isArray(this.newProvider.config.platforms) ? this.newProvider.config.platforms : [];
					const versions = Array.isArray(this.newProvider.config.versions) ? this.newProvider.config.versions : [];
					this.selectedOCPClientChannels = channels.map(v => String(v));
					this.selectedOCPClientPlatforms = platforms.length > 0 ? platforms.map(v => String(v)) : ['linux', 'linux-arm64'];
					this.newProvider.config.versions_str = versions.map(v => String(v)).join(', ');
					if (!this.newProvider.config.output_dir) {
						this.newProvider.config.output_dir = 'ocp-clients';
					}
				}

				if (pc.type === 'container_images') {
					const images = Array.isArray(this.newProvider.config.images) ? this.newProvider.config.images : [];
					this.containerImageRefs = images.map(v => String(v).trim()).filter(v => v);
					this.containerImageInput = '';
					if (!this.newProvider.config.output_dir) {
						this.newProvider.config.output_dir = 'images';
					}
				}
			},

			cancelForm() {
				this.showAddForm = false;
				this.resetForm();
			},

			deepClone(value) {
				return JSON.parse(JSON.stringify(value || {}));
			},

		epelVersions: [],
		epelVersion: '',
		epelArch: 'x86_64',
		epelMirrors: [],
		selectedMirror: null,
		discoveringMirrors: false,
		testingSpeed: false,
		speedResults: [],

		ocpChannels: [],
		ocpReleases: [],
		rhcosVersions: [],
		ocpVersionsLoaded: false,
		loadingVersions: false,
		selectedVersions: [],

		// OCP Clients provider state
		ocpClientTracks: null,
		ocpClientsFetching: false,
		selectedOCPClientChannels: [],
		selectedOCPClientPlatforms: ['linux', 'linux-arm64'],
		containerImageInput: '',
		containerImageRefs: [],

		async init() {
			await this.loadConfigs();
			try {
				const resp = await fetch('/api/mirrors/epel/versions');
				if (resp.ok) this.epelVersions = await resp.json();
			} catch (e) {
				console.error('Failed to load EPEL versions:', e);
			}
		},

		async loadConfigs() {
			try {
				const resp = await fetch('/api/providers/config');
				this.configs = await resp.json();
			} catch (e) {
				console.error('Failed to load configs:', e);
			}
		},

		getFileCount(name) {
			return this.statuses[name] ? this.statuses[name].fileCount : 0;
		},

		getFileSize(name) {
			const size = this.statuses[name] ? this.statuses[name].totalSize : 0;
			return formatBytes(size);
		},

		parseContainerImageLines(text) {
			if (!text) return [];
			return text
				.split(/\r?\n/)
				.map(line => line.trim())
				.filter(line => line && !line.startsWith('#'));
		},

		addContainerImages(lines) {
			const existing = new Set(this.containerImageRefs.map(v => String(v).trim()));
			lines.forEach(line => {
				const v = String(line || '').trim();
				if (!v || existing.has(v)) return;
				existing.add(v);
				this.containerImageRefs.push(v);
			});
		},

		addContainerImagesFromInput() {
			const lines = this.parseContainerImageLines(this.containerImageInput);
			this.addContainerImages(lines);
			this.containerImageInput = '';
		},

		async importContainerImageFile(event) {
			const input = event.target;
			const file = input && input.files && input.files[0];
			if (!file) return;
			try {
				const text = await file.text();
				const lines = this.parseContainerImageLines(text);
				this.addContainerImages(lines);
			} catch (e) {
				this.message = 'Failed to read import file: ' + e.message;
				this.messageType = 'error';
			} finally {
				input.value = '';
			}
		},

		async discoverEPELMirrors() {
			this.discoveringMirrors = true;
			this.epelMirrors = [];
			this.speedResults = [];
			this.selectedMirror = null;
			try {
				const resp = await fetch('/api/mirrors/epel?version=' + this.epelVersion + '&arch=' + this.epelArch);
				if (resp.ok) {
					this.epelMirrors = await resp.json();
				} else {
					const err = await resp.json();
					this.message = err.error || 'Failed to discover mirrors';
					this.messageType = 'error';
				}
			} catch (e) {
				this.message = 'Network error: ' + e.message;
				this.messageType = 'error';
			}
			this.discoveringMirrors = false;
		},

		async testMirrorSpeed() {
			this.testingSpeed = true;
			this.speedResults = [];
			const urls = this.epelMirrors.map(m => m.url);
			try {
				const resp = await fetch('/api/mirrors/speedtest', {
					method: 'POST',
					headers: {'Content-Type': 'application/json'},
					body: JSON.stringify({urls: urls, top_n: 10})
				});
				if (resp.ok) {
					this.speedResults = await resp.json();
					const speedMap = {};
					this.speedResults.forEach(r => { speedMap[r.url] = r; });
					this.epelMirrors.sort((a, b) => {
						const sa = speedMap[a.url], sb = speedMap[b.url];
						if (!sa || sa.error) return 1;
						if (!sb || sb.error) return -1;
						return sb.throughput_kbps - sa.throughput_kbps;
					});
				}
			} catch (e) {
				console.error('Speed test failed:', e);
			}
			this.testingSpeed = false;
		},

		getSpeedResult(url, field) {
			const r = this.speedResults.find(s => s.url === url);
			if (!r) return '-';
			if (r.error) return 'err';
			if (field === 'latency') return r.latency_ms + 'ms';
			if (field === 'throughput') return r.throughput_kbps > 0 ? r.throughput_kbps.toFixed(1) + ' KB/s' : '-';
			return '-';
		},

		selectMirror(m) {
			this.selectedMirror = m.url;
			const repoName = 'epel-' + this.epelVersion;
			if (this.newProvider.config.repos.length === 0) {
				this.newProvider.config.repos.push({name: '', base_url: '', output_dir: ''});
			}
			this.newProvider.config.repos[0].name = repoName;
			this.newProvider.config.repos[0].base_url = m.url;
			this.newProvider.config.repos[0].output_dir = repoName;
			if (!this.newProvider.name) {
				this.newProvider.name = repoName;
			}
		},

		async loadOCPVersions() {
			this.loadingVersions = true;
			this.ocpChannels = [];
			this.ocpReleases = [];
			this.rhcosVersions = [];
			this.selectedVersions = [];
			try {
				const resp = await fetch('/api/mirrors/ocp/versions');
				if (resp.ok) {
					const data = await resp.json();
					if (data.ocp) {
						this.ocpChannels = data.ocp.filter(v => v.channel !== 'release');
						this.ocpReleases = data.ocp.filter(v => v.channel === 'release');
					}
					if (data.rhcos) {
						this.rhcosVersions = data.rhcos;
					}
					this.ocpVersionsLoaded = true;
					if (!this.newProvider.config.base_url) {
						if (this.newProvider.type === 'ocp_binaries') {
							this.newProvider.config.base_url = 'https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp';
						} else if (this.newProvider.type === 'rhcos') {
							this.newProvider.config.base_url = 'https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos';
						}
					}
				} else {
					const err = await resp.json();
					this.message = err.error || 'Failed to load versions';
					this.messageType = 'error';
				}
			} catch (e) {
				this.message = 'Network error: ' + e.message;
				this.messageType = 'error';
			}
			this.loadingVersions = false;
		},

		async fetchOCPClientChannels() {
			this.ocpClientsFetching = true;
			this.ocpClientTracks = null;
			try {
				const resp = await fetch('/api/ocp/tracks');
				if (resp.ok) {
					this.ocpClientTracks = await resp.json();
				} else {
					const err = await resp.json();
					this.message = err.error || 'Failed to fetch OCP channels';
					this.messageType = 'error';
				}
			} catch (e) {
				this.message = 'Network error: ' + e.message;
				this.messageType = 'error';
			}
			this.ocpClientsFetching = false;
		},

			async saveProvider() {
				this.message = '';
				const cfg = Object.assign({}, this.newProvider.config);

			if (this.newProvider.type === 'container_images') {
				this.addContainerImagesFromInput();
				cfg.images = this.containerImageRefs.slice();
				if (!cfg.output_dir) cfg.output_dir = 'images';
				delete cfg.repos;
				delete cfg.base_url;
				delete cfg.versions_str;
				delete cfg.versions;
				delete cfg.channels;
				delete cfg.platforms;
				delete cfg.oc_mirror_binary;
				delete cfg.imageset_config;
			} else if (this.newProvider.type === 'ocp_clients') {
				// OCP Clients: channels, platforms, pinned versions
				cfg.channels = this.selectedOCPClientChannels;
				cfg.platforms = this.selectedOCPClientPlatforms;
				if (cfg.versions_str) {
					cfg.versions = cfg.versions_str.split(',').map(v => v.trim()).filter(v => v);
				}
				delete cfg.versions_str;
				// Clean up fields not relevant to this type
				delete cfg.repos;
				delete cfg.base_url;
				if (!cfg.output_dir) cfg.output_dir = 'ocp-clients';
				if (!this.newProvider.name) {
					this.newProvider.name = 'ocp-clients';
				}
			} else if (this.selectedVersions.length > 0) {
				cfg.versions = this.selectedVersions;
			} else if (cfg.versions_str) {
				cfg.versions = cfg.versions_str.split(',').map(v => v.trim()).filter(v => v);
			}
			if (this.newProvider.type !== 'ocp_clients') {
				delete cfg.versions_str;
			}

			if (cfg.repos) {
				cfg.repos = cfg.repos.filter(r => r.name || r.base_url);
			}

				const body = {
					name: this.newProvider.name,
					type: this.newProvider.type,
					enabled: this.newProvider.enabled,
					config: cfg
				};

				try {
					const isEditing = this.isEditing;
					const url = isEditing
						? ('/api/providers/config/' + encodeURIComponent(this.editingProviderName))
						: '/api/providers/config';
					const method = isEditing ? 'PUT' : 'POST';
					const resp = await fetch(url, {
						method: method,
						headers: {'Content-Type': 'application/json'},
						body: JSON.stringify(body)
					});

					if (resp.ok) {
						this.message = isEditing ? 'Provider updated successfully' : 'Provider created successfully';
						this.messageType = 'success';
						this.showAddForm = false;
						this.resetForm();
						await this.loadConfigs();
					} else {
						const err = await resp.json();
						this.message = err.error || (isEditing ? 'Failed to update provider' : 'Failed to create provider');
						this.messageType = 'error';
					}
				} catch (e) {
				this.message = 'Network error: ' + e.message;
				this.messageType = 'error';
			}
		},

		async toggleProvider(name) {
			// Optimistically update local state for immediate UI feedback
			const idx = this.configs.findIndex(c => c.name === name);
			if (idx !== -1) {
				this.configs[idx].enabled = !this.configs[idx].enabled;
			}
			try {
				const resp = await fetch('/api/providers/config/' + name + '/toggle', {method: 'POST'});
				if (resp.ok) {
					const updated = await resp.json();
					// Apply server state to ensure consistency
					if (idx !== -1) {
						this.configs[idx].enabled = updated.enabled;
					}
				} else {
					// Revert on failure
					if (idx !== -1) {
						this.configs[idx].enabled = !this.configs[idx].enabled;
					}
				}
			} catch (e) {
				// Revert on error
				if (idx !== -1) {
					this.configs[idx].enabled = !this.configs[idx].enabled;
				}
				console.error('Toggle failed:', e);
			}
		},

		async deleteProvider(name) {
			if (!confirm('Delete provider "' + name + '"? This cannot be undone.')) return;
			try {
				const resp = await fetch('/api/providers/config/' + name, {method: 'DELETE'});
				if (resp.ok) {
					await this.loadConfigs();
				}
			} catch (e) {
				console.error('Delete failed:', e);
			}
		},

			resetForm() {
				this.isEditing = false;
				this.editingProviderName = '';
				this.newProvider = {
					name: '',
					type: '',
				enabled: true,
				config: {
					repos: [{name: '', base_url: '', output_dir: ''}],
					base_url: '',
					output_dir: '',
					versions_str: ''
				}
			};
			this.epelMirrors = [];
			this.selectedMirror = null;
			this.speedResults = [];
			this.ocpVersionsLoaded = false;
			this.selectedVersions = [];
			this.ocpClientTracks = null;
			this.selectedOCPClientChannels = [];
			this.selectedOCPClientPlatforms = ['linux', 'linux-arm64'];
			this.containerImageInput = '';
			this.containerImageRefs = [];
		}
	};
}

</script>
{{end}}
